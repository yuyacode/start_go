package main

import (
	"fmt"
	"sync"
	"time"
)

func chan_func() {

	// チャネルは、ゴルーチンとゴルーチンの間でデータの受け渡しを司るためにデザインされた、Go特有のデータ構造
	// チャネルとは、複数のゴルーチン間で安全にデータを共有するための仕組み
	// つまり、ゴルーチンによる非同期処理を必要としないプログラムでは、原則使用する必要はない

	// int型のチャネルを表す型
	// var ch chan int

	// チャネルには、Goの他データ型にはない特殊なサブタイプを指定可能
	// <-chanを使用すると、そのチャネルは受信専用チャネルとなる
	// var ch1 <-chan int
	// chan<-を使用すると、送信専用チャネルとなる
	// var ch2 chan<- int
	// このようなオプションを指定しないchanは、送受信可能な双方向チャネルとして機能する

	// Goのデータ型は厳密であり、異なる型の変数同士の代入は原則コンパイルエラーになる
	// しかし、チャネルのサブタイプは少し事情が異なる
	// var (
	// 	ch3 chan int
	// 	ch4 <-chan int
	// 	ch5 chan<- int
	// )
	// 下記は、チャネルとそのサブタイプ間における代入可否
	// 送受信可能な双方向チャネルのみ、受信専用,送信専用に代入可能。それ以外はNG
	// ch4 = ch3  // OK
	// ch5 = ch3  // OK
	// ch3 = ch4  // NG
	// ch5 = ch4  // NG
	// ch3 = ch5  // NG
	// ch4 = ch5  // NG

	// チャネル自身は、本質的には受信も送信も可能なキューのようなデータ構造
	// 実際は多くの場面で、受信専用として処理されるか、送信専用として処理されるか、明確に分かれる
	// 基本となるのは、あくまでchanではあるものの、「局面に応じて<-chanやchan<-に切り替えることを意図した仕組み」であることを理解する

	// チャネルに関しても、組み込み関数makeを使用して生成可能
	// makeへ２番目の引数を渡すことで、チャネルのバッファサイズを指定可能
	// 明示的に指定されていない場合、バッファサイズは0
	// ch6 := make(chan int)     // バッファサイズ：0
	// ch7 := make(chan int, 8)  // バッファサイズ：8

	// バッファなしチャネルを使用する目的の一つは、ゴルーチン間での同期を実現すること
	// この同期により、送信と受信が一対一で対応し、送信されたデータが受信されるまでの間、送信側は次の操作に進めないため、同期処理が可能になる

	// チャネルとは、キュー（待ち行列）の性質を備えるデータ構造
	// チャネルのバッファとは、このキューを格納する領域のこと
	// すなわち、キューのサイズと見なすことができる

	// キューにはFIFOの性質があり、先にキューにenqueueされたデータを、先にdequeueできるという特性がある
	// すなわち、データを取り出す順序が保証されるという特性があり、Goのチャネルも同様の性質を備えている

	// チャネルが保持するデータに対する操作は「送信」か「受信」の２パターンのみ
	// 送受信ともに演算子<-を使用
	// ch8 := make(chan int, 10)

	// チャネルに整数５を送信
	// ch8 <- 5
	// チャネルから整数値を受信
	// i := <-ch8

	// チャネルはキューとしての性質を持つデータ構造ではあるが、Goプログラム中で単なるキューとして利用するようにはデザインされていない
	// チャネルはあくまでも複数のゴルーチン間で安全にデータを共有するための仕組みである

	// チャネルからデータを受信する処理は、裏返せば、他ゴルーチンがチャネルにデータを送信するのを待つということ
	// 唯一存在するメインゴルーチンは、チャネルからのデータ受信のために眠ってしまったものの、そのチャネルにデータを送信してくれるゴルーチンは存在しない
	// このような状態をGoランタイムはデッドロックであると検知し、ランタイムパニックを検知させたというのが事の真相
	// ch9 := make(chan int)
	// fmt.Println(<-ch9)  // fatal error: all goroutines are asleep - deadlock!

	// バッファなしチャネルを使用しているため、送信と受信が１対１の関係性になり、すなわち送信側と受信側で同期処理が行われる
	// これにより、「送信処理だけが早期に終了し、これによりメインゴルーチンが終了し、それによりサブゴルーチンが強制終了することで、受信側が全ての受信を終える前に処理が終了してしまう」事態を防ぐことができている
	// バッファありチャネルの場合は、これが起こるケースがあるので、sync.WaitGroupを使用してサブゴルーチンの終了を待ったり、チャネルを閉じることが必要（チャネルのクローズは後述）
	// ch10 := make(chan int)
	// go receiver(ch10)
	// i := 0
	// for i <= 100 {
	// 	ch10 <- i
	// 	i++
	// }

	// len関数：チャネルのバッファ内に溜められているデータ数を取得する
	// ch11 := make(chan string, 3)
	// ch11 <- "Apple"
	// fmt.Println(len(ch11))  // 1
	// ch11 <- "Banana"
	// ch11 <- "Cherry"
	// fmt.Println(len(ch11))  // 3

	// 次のようなコードは書くべきではない
	// 仮に、len(ch11) > 0が成立したとしても、次の瞬間にはチャネルの状態が変化している（バッファ内が空になっている）可能性が十分にあるため
	// if len(ch11) > 0 {
	// 	// バッファ内のデータが存在する場合
	// 	i := <-ch11
	// }

	// チャネルにおけるデッドロックとは、プログラム内のすべてのゴルーチンが、チャネル操作（送信または受信）でブロックされ、それ以上の進行が不可能になる状態を指す
	// この状態では、どのゴルーチンも待っている操作（送信または受信）を完了することができず、プログラムは処理を進めることができない

	// cap関数：チャネルのバッファサイズを取得
	// チャネルのバッファサイズは変更不可能であり、チャネル定義時のみ指定可能
	// なので、有効に使用できる局面は正直少ない
	// ch12 := make(chan string)
	// fmt.Println(cap(ch12))  // 0

	// ch13 := make(chan string, 3)
	// fmt.Println(cap(ch13))  // 3

	// クローズしたチャネルに送信することはできない
	// ch14 := make(chan int, 1)
	// close(ch14)
	// ch14 <- 1  // panic: send on closed channel

	// チャネルがクローズされても、チャネルのバッファ内に溜められたデータについては問題なく受信できる
	// バッファ内が空になった場合は、チャネルが内包する型の初期値を受信し続ける。ランタイムパニック等は発生しない
	// チャネルのクローズは、送信側の役割であり、受信側がチャネルをクローズすることはないと認識して良い
	// ch15 := make(chan int, 3)
	// ch15 <- 1
	// ch15 <- 2
	// ch15 <- 3
	// close(ch15)
	// fmt.Println(<-ch15)  // 1
	// fmt.Println(<-ch15)  // 2
	// fmt.Println(<-ch15)  // 3
	// fmt.Println(<-ch15)  // 0
	// fmt.Println(<-ch15)  // 0

	// 下記コードの場合、送信側がサブゴルーチンとしての立ち位置を取るため、sync.WaitGroupを使用した制御が不要になる
	// ch16 := make(chan int)
	// go produce(ch16)
	// consume(ch16)

	// sync.WaitGroup使って複数ゴルーチンを制御した書き方
	var wg sync.WaitGroup
	ch17 := make(chan int)
	wg.Add(1)
	go produceWg(ch17, &wg)  // $wgで、変数wgのメモリアドレスを渡す  呼び出し元と先で同じwgを共有しないと、Add,Done,Waitの状態を共有できない
	wg.Add(1)
	go consumeWg(ch17, &wg)
	wg.Wait()

}

func produceWg(ch17 chan<- int, wg *sync.WaitGroup) {  // wg *sync.WaitGroup  sync.WaitGroup型のポインタをwgとして受け取る
	defer wg.Done()
	for i := 0; i < 10; i++ {
		ch17 <- i
		time.Sleep(time.Second)
	}
	close(ch17)
}

func consumeWg(ch17 <-chan int, wg *sync.WaitGroup) {
	defer wg.Done()
	// for i := range chという書き方は、チャネルからの受信を継続的に続け、受信したデータを処理しつつ、チャネルのクローズを検知すると自動でループを終了する特別な構文
	// チャネルからのデータの受信、処理、そしてチャネルのクローズ検知を簡潔に記述することができる
	// 明示的なクローズ検知のコードを書く必要がなくなる
	for i := range ch17 {
		fmt.Println("受信データ：", i)
	}
}

// func produce(ch16 chan<- int) {
// 	for i := 0; i <= 10; i++ {
// 		ch16 <- i
// 		time.Sleep(time.Second)  // ここで1秒待機させてみる
// 	}
// 	close(ch16)
// }

// func consume(ch16 <-chan int) {
// 	for {
// 		i, ok := <-ch16
// 		if !ok {
// 			fmt.Println("チャネルがクローズされました")
// 			break
// 		}
// 		fmt.Println("受信データ：", i)
// 	}
// 	// 
// }

// func receiver(ch10 <-chan int) {
// 	for {
// 		i := <-ch10
// 		fmt.Println(i)
// 	}
// }