package main

import (
	"fmt"
)

func pointer() {

	// 定義のみ行ったポインタ型変数の初期値はnil
	// var p *int
	// fmt.Println(p)  // nil

	// 多重ポインタも定義可能
	// 下記は、int型のポインタを参照するポインタを参照するポインタ
	// ３レベルの間接参照を意味する
	// このような多重ポインタを利用するケースは少ないことが考えられるので「このような定義ができる」と認識しておくくらいで良い
	// var p1 ***int

	// スライス、マップ、チャネルといった参照型に対するポインタも定義可能
	// 参照型は、名前の通り、型自体にポインタを使用した参照を含んでいる
	// 参照型へのポインタが必要になる場面はレアなので、これも「可能である」ことを押さえておくくらいで良い
	// var (
	// 	s *[]string
	// 	m *map[int]rune
	// 	ch *chan int
	// )

	// &は「アドレス演算子」と呼ばれる
	var i int
	p := &i
	fmt.Printf("%T\n", p)  // *int
	pp := &p
	fmt.Printf("%T\n", pp)  // **int

	// ポインタ型変数の前に演算子*（間接参照演算子）を置くことで、ポインタ型変数が指し示す（ポインタ型変数に格納されているメモリアドレスに位置する）データ本体の「デリファレンス（dereference）」をすることができる
	// デリファレンスとは、ポインタ型変数が保持するメモリアドレスを経由して、データ本体を参照する仕組みのこと
	var num int
	numPointer := &num
	num = 5
	fmt.Println(*numPointer)  // 5
	*numPointer = 10
	fmt.Println(num)  // 10

	// 値型の参照渡し
	// 関数の引数に値型を渡す場合、値のコピーが発生し、同じメモリ領域の値を共有することができない
	// ただ、下記のようにポインタ型を介することで、１つのメモリ上の値を共有することができる
	val := 1
	inc(&val)
	inc(&val)
	inc(&val)
	fmt.Println(val)  // 4

	// 配列と構造体に関しては、アドレス演算子&とリテラルを組み合わせて、そのリテラルのアドレスを直接取得することが可能
	arrPointer := &[3]int{1, 2, 3}
	pow(arrPointer)
	// Go言語のfmtパッケージは、ポインタを適切にフォーマットして出力する機能を持っている
	// そのため、ポインタ変数をfmt.Printlnで出力する際、fmtパッケージはポインタが指す値をデリファレンスして表示する
	// そして、配列や構造体のポインタの場合、その内容を{}で囲んで出力し、ポインタであることを示すために先頭に&を付ける
	// これはGo言語の標準的な挙動であり、デバッグやログ出力時に非常に便利
	fmt.Println(arrPointer)  // &[1 4 9]
	fmt.Println(*arrPointer)  // [1 4 9]

	// ポインタ型の変数がnilである場合、デリファレンスを実行すると、ランタイムパニックが発生
	// どこかを参照しているかどうか（どこも参照していない状態ではないか）確認する
	var p *int
	fmt.Println(*p)  // ランタイムパニック

}

func pow(p *[3]int) {
	i := 0
	for i < 3 {
		// 括弧()が必要なのは、*演算子よりも配列のインデックス操作[]の方が優先順位が高いため
		// (*p)によってデリファレンスした配列に、[i]を使って要素のインデックスを指定している、という順序
		(*p)[i] = (*p)[i] * (*p)[i]
		i++
	} 
}

func inc(p *int) {
	*p++
}