package main

import (
	"fmt"
)

func slice() {
	
	// int型のスライス
	// var s []int
	// var s []float64
	// var s []string
	// fmt.Println(s)  // []  上記全て、ゼロ値は[]らしい

	// 要素数と容量が10であるint型のスライスを生成
	// s1 := make([]int, 10)
	// fmt.Println(s1)  // [0 0 0 0 0 0 0 0 0 0]

	// s2 := make([]float64, 3)
	// fmt.Println(s2)  // [0 0 0]
	// s2[0] = 3.14
	// s2[1] = 6.28
	// fmt.Println(s2)  // [3.14, 6.28, 0]
	// fmt.Println(s2[4])  // ランタイムパニック

	// 要素数を調べる関数、len関数
	// s3 := make([]int, 8)
	// fmt.Println(len(s3))  // 8

	// len関数は、配列にも使用可能
	// s4 := [3]int {1, 2, 3}
	// fmt.Println(len(s4))  // 3

	// 容量を調べる関数、cap関数
	// s5 := make([]int, 5)
	// fmt.Println(len(s5))  // 5
	// fmt.Println(cap(s5))  // 5

	// s6 := make([]int, 5, 10)
	// fmt.Println(len(s6))  // 5
	// fmt.Println(cap(s6))  // 10

	// スライスはmake関数を使用せず、配列型のリテラルと同様の書き方で定義可能
	// この書き方の場合、容量は個別に指定できないため、次のコードの場合は要素数5, 容量5のスライスが出来上がる
	// s7 := []int {1, 2, 3, 4, 5}
	// fmt.Println(len(s7))  // 5
	// fmt.Println(cap(s7))  // 5

	// arr1 := [5]int {1, 2, 3, 4, 5}
	// arr1 := []int {1, 2, 3, 4, 5}  // スライスにも同様に使用可能
	// s8 := arr1[0:2]  // [1, 2]
	// s9 := arr1[2:]  // [3, 4, 5]
	// s10 := arr1[:4]  // [1, 2, 3, 4]
	// s11 := arr1[:]  // [1, 2, 3, 4, 5]

	// s12 := arr1[len(arr1)-2:]  // [4, 5]
	// fmt.Println(arr1[0:6])  // ランタイムパニック

	// s10[0] = 100
	// fmt.Println(s10)  // [100, 2, 3, 4]
	// fmt.Println(arr1)  // [100, 2, 3, 4, 5]  要素の変更は、元の配列に影響を及ぼす

	// s10 = append(s10, 500)
	// fmt.Println(cap(s10))  // 5
	// 容量以内での要素の追加であれば、それは元の配列にも影響を及ぼす
	// fmt.Println(s10)  // [100, 2, 3, 4, 500]
	// fmt.Println(arr1)  // [100, 2, 3, 4, 500]

	// 容量を超えた要素の追加の場合、元となる配列に要素を追加した新しい配列が作成され、その新しい配列を参照するスライスが新規作成される
	// これにより、新しいスライスは元の配列を参照しなくなるので、スライスへの要素の追加が、元の配列に影響を及ぼさなくなる
	// この挙動を「スライスの拡張」というらしい
	// s10 = append(s10, 600)
	// fmt.Println(s10)  // [100, 2, 3, 4, 500, 600]
	// fmt.Println(arr1)  // [100, 2, 3, 4, 500]

	// スライスに対して容量を超えた要素の追加が行われると、Goランタイムは元の配列よりも大きな新しい配列を割り当て、スライスに追加された要素を含むこの新しい配列を参照するようにスライスを更新します。
	// このプロセスを「スライスの拡張」と呼びます。

	// 文字列に対しても使用可能
	str1 := "abcde"[1:3] // bc
	fmt.Println(str1)

	// しかし、文字を単位にしている訳ではなく、バイト列が単位になっている
	// 文字列"あいうえお"は、UTF-8エンコードにおいて各文字に３バイトを要する
	str2 := "あいうえお"[3:12] // いうえ
	fmt.Println(str2)

}